
In this section we introduce \SLref, which extends \SL 
with nondeterministic strategies,  an \emph{outcome quantifier} that
quantifies over possible outcomes of a strategy profile,
and more importantly, a refining operator that expresses that a
strategy refines another.
We first fix some basic notations.



 \subsection{Syntax}
 \label{sec-SL-definition}

In addition to the sets of propositions $\APf$ and agents $\Agf$, we
now fix $\Varf$, a finite non-empty set of \emph{variables}.



\begin{definition}%[\SLref Syntax]
  \label{def-SLi}
    The syntax of \SLref is defined by the following grammar:
    \begin{align*}
  \phi\egdef &\; p 
  \mid \neg \phi 
  \mid \phi\ou\phi 
               \mid \Estratnd\phi
%               \mid \Estratd\phi  
               \mid \var \refines \varb
               \mid \bind{\var}\phi
%               \mid \unbind\phi
  \mid \Eout\psi               
      \\
      \psi\egdef &\; \phi
                   \mid \neg \psi
                   \mid \psi\ou \psi
                   \mid \X \psi
                   \mid  \psi \until \psi
    \end{align*}
     where 
  $p\in\APf$, $\var,\varb\in\Varf$ and $a\in\Agf$.
\end{definition}

Formulas of type $\phi$ are called \emph{state formulas}, those of type $\psi$
are called \emph{path formulas}, and \SLref consists of all state formulas.


Temporal operators, $\X$ (next) and
 $\until$ (until), have the usual meaning. The \emph{refinement
   operator} expresses that the strategy denoted by a variable $\var$ is more
 restrictive than another one, or that it allows less behaviours: $\var\refines\varb$ reads as ``strategy
 $\var$ refines strategy $\varb$''. The  \emph{strategy
   quantifier}  $\Estratnd$  has its usual meaning, except that it now
 quantifies on \emph{nondeterministic}
 strategies: $\Estratnd\phi$
 reads as ``there exists a nondeterministic
 strategy $\var$
  such that $\phi$
 holds'', where $\var$ is a strategy variable. 
As usual, the \emph{binding operator} $\bind{\var}$ assigns a strategy to an
 agent, and $\bind{\var}\phi$ reads as ``when agent $\ag$ plays strategy $\var$,
 $\phi$ holds''.
 %The \emph{unbinding operator} $\unbind$
%  instead releases agent
% $\ag$ from her current strategy, if she has one, and
% $\bind{\unb}\phi$ reads as ``when
% agent $\ag$ is not assigned any strategy, $\phi$ holds''. 
Finally, the \emph{outcome quantifier} $\Eout$ quantifies on
   outcomes of strategies currently in use: $\Eout\psi$ reads as ``$\psi$
 holds in some
 outcome of the strategies currently used by the players''.

We use usual abbreviations $\top\egdef p\ou\neg p$, $\perp\egdef\neg\top$, $\phi\impl\phi'\egdef \neg \phi \ou \phi'$,
$\phi\equivaut\phi'\egdef \phi\impl\phi'\et \phi'\impl\phi$,
 $\F\phi \egdef \top \until \phi$,   $\always\phi \egdef \neg \F
\neg \phi$ and
 $\Astratnd\phi\egdef\neg\Estratnd\neg\phi$. % and $\Astratd\phi\egdef\neg\Estratd\neg\phi$.

% %\todo{see if still necessary; if so, adapt}
For every formula $\phi\in\SLref$, we let  $\free(\phi)$ be the set of variables that appear
free in $\phi$, \ie, that
appear out of the scope of a strategy quantifier. A formula $\phi$ is a \emph{sentence} if $\free(\phi)$ is empty.
Finally, we let the \emph{size} $|\phi|$ of a formula $\phi$ be the
number of symbols in $\phi$.


\subsection{Semantics}
\label{sec-SLmodels}

 \SLref formulas are interpreted in a \CGS, and the semantics makes
 use of the following additional notions.
% \halfline

% \head{Assignments} 
An \emph{assignment}  $\assign:\Agf\union\Varf \partialto \setstrat$
is a partial function that assigns a strategy  to
each  player and strategy variable in its domain.
For an assignment
$\assign$, player $a$ and  strategy $\strat$,
$\assign[a\mapsto\strat]$ is the assignment of domain
$\dom(\assign)\union\{a\}$ that maps $a$ to $\strat$ and is equal to
$\assign$ on the rest of its domain, and 
$\assign[\var\mapsto \strat]$ is defined similarly, where $\var$ is a
variable. %  also, $\assign[a\mapsto\unb]$ is
 % the restriction of $\assign$ to domain $\dom(\assign)\setminus\{a\}$.
An assignment is
\emph{variable-complete} for a formula $\phi\in\SLref$ if
its domain contains all free variables of $\phi$.

% \halfline
% \head{Outcomes}
For an assignment $\assign$ and a finite play $\fplay$, we let
$\out(\assign,\fplay)$ be the set of infinite plays that start with
$\fplay$ and are then extended by letting players follow the strategies
assigned by $\assign$. Formally,
 $\out(\assign,\fplay)$ is the set of plays of the form $\fplay \cdot
 \pos_{1}\pos_{2}\ldots$ such that for all $i\geq 0$, there exists
 $\jmov$ such that for all $\ag\in\dom(\assign)\inter\Agf$,
 $\jmov_\ag\in\assign(\ag)(\fplay\cdot\pos_{1}\ldots\pos_i)$ \mbox{ and }
 $\pos_{i+1}=\trans(\pos_{i},\jmov)$, \mbox{ with }
 $\pos_{0}=\last(\fplay)$.
 

\begin{definition}%[\SLi semantics]
\label{def-SLi-semantics}
The semantics of a state formula is defined on a \CGS $\CGS$, an
assignment  $\assign$ that is variable-complete for $\phi$, and a
finite play $\fplay$. For a path formula $\psi$, the finite play is
replaced with an infinite play $\iplay$ and an index $i\in\setn$. The
definition by mutual induction is as follows:
\[
\begin{array}{lcl}
 \CGS,\assign,\fplay\modelsSL p & \text{if} & p\in\val(\last(\fplay))\\[3pt]
 \CGS,\assign,\fplay\modelsSL \neg\phi & \text{if} &
  \CGS,\assign,\fplay\not\modelsSL\phi\\[3pt]
 \CGS,\assign,\fplay\modelsSL \phi\ou\phi' & \text{if} &
  \CGS,\assign,\fplay\modelsSL\phi \;\text{ or }\;
  \CGS,\assign,\fplay\modelsSL\phi' \\[3pt]
 \CGS,\assign,\fplay\modelsSL\Estratnd\phi  & \text{if} & 
\exists\,   \strat\in\setstratnd \;\text{s.t.} \;
                                                          \CGS,\assign[\var\mapsto\strat],\fplay\modelsSL
                                                          \phi\\[3pt]
%    \CGS,\assign,\fplay\modelsSL\Estratd\phi  & \text{if} & 
% \exists\,   \strat\in\setstratd \;\text{s.t.} \;
%                                                            \CGS,\assign[\var\mapsto\strat],\fplay\modelsSL
%                                                          \phi\\[3pt]
   \CGS,\assign,\fplay\modelsSL \var\refines\varb & \text{if} &
                                                              \assign(\var)
                                                              \mbox{
                                                              refines
                                                                }\assign(\varb)
  \mbox{ after }\fplay\\[3pt]
 \CGS,\assign,\fplay\modelsSL \bind{\var}\phi & \text{if} &
 \CGS,\assign[\ag\mapsto\assign(\var)],\fplay\modelsSL \phi\\[3pt]  
 % \CGS,\assign,\fplay\modelsSL \bind{\unb}\phi & \text{if} &
 %          \CGS,\assign[\ag\mapsto\unb],\fplay\modelsSL \phi\\[3pt]
 \CGS,\assign,\fplay\modelsSL \Eout\psi & \text{if} & \exists\iplay \in
                                                         \out(\assign,\fplay)
                                                         \text{ s.t. }
  \\
  & &\quad   \CGS,\assign,\iplay,|\fplay|-1\modelsSL \psi\\[5pt]
    \CGS,\assign,\iplay,i\modelsSL \phi & \text{if} &
                                                         \CGS,\assign,\iplay_{\leq i}\modelsSL\phi\\[3pt]
   \CGS,\assign,\iplay,i\modelsSL \neg\psi & \text{if} &
  \CGS,\assign,\iplay,i\not\modelsSL\psi\\[3pt]
 \CGS,\assign,\iplay,i\modelsSL \psi\ou\psi' & \text{if} &
  \CGS,\assign,\iplay,i\modelsSL\psi \;\text{ or }\;
  \CGS,\assign,\iplay,i\modelsSL\psi' \\[3pt]
  \CGS,\assign,\iplay,i\modelsSL\X\psi & \text{if} &
  \CGS,\assign,\iplay,i+1\modelsSL\psi\\[3pt]
\CGS,\assign,\iplay,i\modelsSL\psi\until\psi' & \text{if} & \exists\, j\geq i
   \mbox{ s.t. }\CGS,\assign,\iplay,j\modelsSL \psi' \text{ and,}\\ 
   & & \forall\, k \text{ s.t. } i\leq k <j,
\; \CGS,\assign,\iplay,k\modelsSL \psi
\end{array}
\]
\end{definition}


We give some examples of useful notions that can be expressed in this
logic. 

\begin{example}[Strategy equality]
  First, it is easy to see that a strategy $\strat$ refines a strategy
  $\strat'$ if $\strat \refines \strat'$ and
  $\strat'\refines\strat$. We thus define the abbreviation
  \[\var = \varb \quad := \quad \var \refines \varb \wedge \varb
    \refines \var\]
  We thus have that $\CGS,\assign,\fplay\models \var = \varb$ if, and
  only if, $\substrat{\assign(\var)}=\substrat{\assign(\varb)}$. And in
  particular, $\CGS,\assign,\pos_\init\models\var=\varb$ if, and only
  if, $\assign(\var)=\assign(\varb)$.
  We also let $\var \neq \varb := \neg (\var = \varb)$ and
  $\var\refinesstr\varb := \var \refines \varb \wedge \var \neq \varb$.
\end{example}

\begin{example}[Deterministic strategies]
  We can also express that a strategy, or its refinement to
  continuations of the current finite play, is deterministic, with the
  following formula:
  \[\phidet \quad := \quad \forall \varb \; \varb \refines \var \impl \var\refines\varb\]
\end{example}

\begin{example}[Maximal permissive strategies]
  Given a formula $\phi(\var)$ we can express that a strategy $\var$
  is maximally permissive with regards to  $\phi(\var)$. Define formula $\maxperm(\var,\phi)$ as
  follows:
  \[\maxperm(\var,\phi) \quad := \quad \phi(\var) \wedge (\forall \varb \;
    \var \refinesstr \varb \impl \neg \phi(\varb))\]
  For instance, if we have two antagonistic players $\ag$ and $\agb$,
  and $\ag$ tries to ensure the safety property $\always p$, we can let $\phi(\var)=\forall \varc
  \bind[\ag]{\var}\bind[\agb]{\varc}\always p$, and it then holds that
  $\CGS,\assign,\pos_\init\models \maxperm(\var,\phi)$ if, and only
  if, $\assign(\var)$ is a maximally permissive winning strategy for $\ag$.
\end{example}

In the following sections we  show how \SLref captures a number of
important problems related to strategy synthesis and nondeterministic strategies. 






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
